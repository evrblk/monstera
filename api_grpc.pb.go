// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.31.1
// source: api.proto

package monstera

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	MonsteraApi_Update_FullMethodName                = "/com.evrblk.monstera.MonsteraApi/Update"
	MonsteraApi_Read_FullMethodName                  = "/com.evrblk.monstera.MonsteraApi/Read"
	MonsteraApi_AppendEntriesPipeline_FullMethodName = "/com.evrblk.monstera.MonsteraApi/AppendEntriesPipeline"
	MonsteraApi_AppendEntries_FullMethodName         = "/com.evrblk.monstera.MonsteraApi/AppendEntries"
	MonsteraApi_RequestVote_FullMethodName           = "/com.evrblk.monstera.MonsteraApi/RequestVote"
	MonsteraApi_TimeoutNow_FullMethodName            = "/com.evrblk.monstera.MonsteraApi/TimeoutNow"
	MonsteraApi_InstallSnapshot_FullMethodName       = "/com.evrblk.monstera.MonsteraApi/InstallSnapshot"
	MonsteraApi_HealthCheck_FullMethodName           = "/com.evrblk.monstera.MonsteraApi/HealthCheck"
	MonsteraApi_LeadershipTransfer_FullMethodName    = "/com.evrblk.monstera.MonsteraApi/LeadershipTransfer"
	MonsteraApi_TriggerSnapshot_FullMethodName       = "/com.evrblk.monstera.MonsteraApi/TriggerSnapshot"
	MonsteraApi_AddVoter_FullMethodName              = "/com.evrblk.monstera.MonsteraApi/AddVoter"
	MonsteraApi_UpdateClusterConfig_FullMethodName   = "/com.evrblk.monstera.MonsteraApi/UpdateClusterConfig"
)

// MonsteraApiClient is the client API for MonsteraApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MonsteraApiClient interface {
	Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*UpdateResponse, error)
	Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*ReadResponse, error)
	// AppendEntriesPipeline opens an AppendEntries message stream.
	AppendEntriesPipeline(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[AppendEntriesRequest, AppendEntriesResponse], error)
	// AppendEntries performs a single append entries request / response.
	AppendEntries(ctx context.Context, in *AppendEntriesRequest, opts ...grpc.CallOption) (*AppendEntriesResponse, error)
	// RequestVote is the command used by a candidate to ask a Raft peer for a
	// vote in an election.
	RequestVote(ctx context.Context, in *RequestVoteRequest, opts ...grpc.CallOption) (*RequestVoteResponse, error)
	// TimeoutNow is used to start a leadership transfer to the target node.
	TimeoutNow(ctx context.Context, in *TimeoutNowRequest, opts ...grpc.CallOption) (*TimeoutNowResponse, error)
	// InstallSnapshot is the command sent to a Raft peer to bootstrap its log
	// (and state machine) from a snapshot on another peer.
	InstallSnapshot(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[InstallSnapshotRequest, InstallSnapshotResponse], error)
	HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
	LeadershipTransfer(ctx context.Context, in *LeadershipTransferRequest, opts ...grpc.CallOption) (*LeadershipTransferResponse, error)
	TriggerSnapshot(ctx context.Context, in *TriggerSnapshotRequest, opts ...grpc.CallOption) (*TriggerSnapshotResponse, error)
	AddVoter(ctx context.Context, in *AddVoterRequest, opts ...grpc.CallOption) (*AddVoterResponse, error)
	UpdateClusterConfig(ctx context.Context, in *UpdateClusterConfigRequest, opts ...grpc.CallOption) (*UpdateClusterConfigResponse, error)
}

type monsteraApiClient struct {
	cc grpc.ClientConnInterface
}

func NewMonsteraApiClient(cc grpc.ClientConnInterface) MonsteraApiClient {
	return &monsteraApiClient{cc}
}

func (c *monsteraApiClient) Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*UpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateResponse)
	err := c.cc.Invoke(ctx, MonsteraApi_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monsteraApiClient) Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*ReadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadResponse)
	err := c.cc.Invoke(ctx, MonsteraApi_Read_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monsteraApiClient) AppendEntriesPipeline(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[AppendEntriesRequest, AppendEntriesResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MonsteraApi_ServiceDesc.Streams[0], MonsteraApi_AppendEntriesPipeline_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AppendEntriesRequest, AppendEntriesResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MonsteraApi_AppendEntriesPipelineClient = grpc.BidiStreamingClient[AppendEntriesRequest, AppendEntriesResponse]

func (c *monsteraApiClient) AppendEntries(ctx context.Context, in *AppendEntriesRequest, opts ...grpc.CallOption) (*AppendEntriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AppendEntriesResponse)
	err := c.cc.Invoke(ctx, MonsteraApi_AppendEntries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monsteraApiClient) RequestVote(ctx context.Context, in *RequestVoteRequest, opts ...grpc.CallOption) (*RequestVoteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RequestVoteResponse)
	err := c.cc.Invoke(ctx, MonsteraApi_RequestVote_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monsteraApiClient) TimeoutNow(ctx context.Context, in *TimeoutNowRequest, opts ...grpc.CallOption) (*TimeoutNowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TimeoutNowResponse)
	err := c.cc.Invoke(ctx, MonsteraApi_TimeoutNow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monsteraApiClient) InstallSnapshot(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[InstallSnapshotRequest, InstallSnapshotResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MonsteraApi_ServiceDesc.Streams[1], MonsteraApi_InstallSnapshot_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[InstallSnapshotRequest, InstallSnapshotResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MonsteraApi_InstallSnapshotClient = grpc.ClientStreamingClient[InstallSnapshotRequest, InstallSnapshotResponse]

func (c *monsteraApiClient) HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, MonsteraApi_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monsteraApiClient) LeadershipTransfer(ctx context.Context, in *LeadershipTransferRequest, opts ...grpc.CallOption) (*LeadershipTransferResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LeadershipTransferResponse)
	err := c.cc.Invoke(ctx, MonsteraApi_LeadershipTransfer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monsteraApiClient) TriggerSnapshot(ctx context.Context, in *TriggerSnapshotRequest, opts ...grpc.CallOption) (*TriggerSnapshotResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TriggerSnapshotResponse)
	err := c.cc.Invoke(ctx, MonsteraApi_TriggerSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monsteraApiClient) AddVoter(ctx context.Context, in *AddVoterRequest, opts ...grpc.CallOption) (*AddVoterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddVoterResponse)
	err := c.cc.Invoke(ctx, MonsteraApi_AddVoter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monsteraApiClient) UpdateClusterConfig(ctx context.Context, in *UpdateClusterConfigRequest, opts ...grpc.CallOption) (*UpdateClusterConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateClusterConfigResponse)
	err := c.cc.Invoke(ctx, MonsteraApi_UpdateClusterConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MonsteraApiServer is the server API for MonsteraApi service.
// All implementations must embed UnimplementedMonsteraApiServer
// for forward compatibility.
type MonsteraApiServer interface {
	Update(context.Context, *UpdateRequest) (*UpdateResponse, error)
	Read(context.Context, *ReadRequest) (*ReadResponse, error)
	// AppendEntriesPipeline opens an AppendEntries message stream.
	AppendEntriesPipeline(grpc.BidiStreamingServer[AppendEntriesRequest, AppendEntriesResponse]) error
	// AppendEntries performs a single append entries request / response.
	AppendEntries(context.Context, *AppendEntriesRequest) (*AppendEntriesResponse, error)
	// RequestVote is the command used by a candidate to ask a Raft peer for a
	// vote in an election.
	RequestVote(context.Context, *RequestVoteRequest) (*RequestVoteResponse, error)
	// TimeoutNow is used to start a leadership transfer to the target node.
	TimeoutNow(context.Context, *TimeoutNowRequest) (*TimeoutNowResponse, error)
	// InstallSnapshot is the command sent to a Raft peer to bootstrap its log
	// (and state machine) from a snapshot on another peer.
	InstallSnapshot(grpc.ClientStreamingServer[InstallSnapshotRequest, InstallSnapshotResponse]) error
	HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	LeadershipTransfer(context.Context, *LeadershipTransferRequest) (*LeadershipTransferResponse, error)
	TriggerSnapshot(context.Context, *TriggerSnapshotRequest) (*TriggerSnapshotResponse, error)
	AddVoter(context.Context, *AddVoterRequest) (*AddVoterResponse, error)
	UpdateClusterConfig(context.Context, *UpdateClusterConfigRequest) (*UpdateClusterConfigResponse, error)
	mustEmbedUnimplementedMonsteraApiServer()
}

// UnimplementedMonsteraApiServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMonsteraApiServer struct{}

func (UnimplementedMonsteraApiServer) Update(context.Context, *UpdateRequest) (*UpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedMonsteraApiServer) Read(context.Context, *ReadRequest) (*ReadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Read not implemented")
}
func (UnimplementedMonsteraApiServer) AppendEntriesPipeline(grpc.BidiStreamingServer[AppendEntriesRequest, AppendEntriesResponse]) error {
	return status.Errorf(codes.Unimplemented, "method AppendEntriesPipeline not implemented")
}
func (UnimplementedMonsteraApiServer) AppendEntries(context.Context, *AppendEntriesRequest) (*AppendEntriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppendEntries not implemented")
}
func (UnimplementedMonsteraApiServer) RequestVote(context.Context, *RequestVoteRequest) (*RequestVoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestVote not implemented")
}
func (UnimplementedMonsteraApiServer) TimeoutNow(context.Context, *TimeoutNowRequest) (*TimeoutNowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TimeoutNow not implemented")
}
func (UnimplementedMonsteraApiServer) InstallSnapshot(grpc.ClientStreamingServer[InstallSnapshotRequest, InstallSnapshotResponse]) error {
	return status.Errorf(codes.Unimplemented, "method InstallSnapshot not implemented")
}
func (UnimplementedMonsteraApiServer) HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedMonsteraApiServer) LeadershipTransfer(context.Context, *LeadershipTransferRequest) (*LeadershipTransferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeadershipTransfer not implemented")
}
func (UnimplementedMonsteraApiServer) TriggerSnapshot(context.Context, *TriggerSnapshotRequest) (*TriggerSnapshotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TriggerSnapshot not implemented")
}
func (UnimplementedMonsteraApiServer) AddVoter(context.Context, *AddVoterRequest) (*AddVoterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddVoter not implemented")
}
func (UnimplementedMonsteraApiServer) UpdateClusterConfig(context.Context, *UpdateClusterConfigRequest) (*UpdateClusterConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateClusterConfig not implemented")
}
func (UnimplementedMonsteraApiServer) mustEmbedUnimplementedMonsteraApiServer() {}
func (UnimplementedMonsteraApiServer) testEmbeddedByValue()                     {}

// UnsafeMonsteraApiServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MonsteraApiServer will
// result in compilation errors.
type UnsafeMonsteraApiServer interface {
	mustEmbedUnimplementedMonsteraApiServer()
}

func RegisterMonsteraApiServer(s grpc.ServiceRegistrar, srv MonsteraApiServer) {
	// If the following call pancis, it indicates UnimplementedMonsteraApiServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MonsteraApi_ServiceDesc, srv)
}

func _MonsteraApi_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonsteraApiServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonsteraApi_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonsteraApiServer).Update(ctx, req.(*UpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonsteraApi_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonsteraApiServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonsteraApi_Read_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonsteraApiServer).Read(ctx, req.(*ReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonsteraApi_AppendEntriesPipeline_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MonsteraApiServer).AppendEntriesPipeline(&grpc.GenericServerStream[AppendEntriesRequest, AppendEntriesResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MonsteraApi_AppendEntriesPipelineServer = grpc.BidiStreamingServer[AppendEntriesRequest, AppendEntriesResponse]

func _MonsteraApi_AppendEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppendEntriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonsteraApiServer).AppendEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonsteraApi_AppendEntries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonsteraApiServer).AppendEntries(ctx, req.(*AppendEntriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonsteraApi_RequestVote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestVoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonsteraApiServer).RequestVote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonsteraApi_RequestVote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonsteraApiServer).RequestVote(ctx, req.(*RequestVoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonsteraApi_TimeoutNow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TimeoutNowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonsteraApiServer).TimeoutNow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonsteraApi_TimeoutNow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonsteraApiServer).TimeoutNow(ctx, req.(*TimeoutNowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonsteraApi_InstallSnapshot_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MonsteraApiServer).InstallSnapshot(&grpc.GenericServerStream[InstallSnapshotRequest, InstallSnapshotResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MonsteraApi_InstallSnapshotServer = grpc.ClientStreamingServer[InstallSnapshotRequest, InstallSnapshotResponse]

func _MonsteraApi_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonsteraApiServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonsteraApi_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonsteraApiServer).HealthCheck(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonsteraApi_LeadershipTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeadershipTransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonsteraApiServer).LeadershipTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonsteraApi_LeadershipTransfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonsteraApiServer).LeadershipTransfer(ctx, req.(*LeadershipTransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonsteraApi_TriggerSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TriggerSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonsteraApiServer).TriggerSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonsteraApi_TriggerSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonsteraApiServer).TriggerSnapshot(ctx, req.(*TriggerSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonsteraApi_AddVoter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddVoterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonsteraApiServer).AddVoter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonsteraApi_AddVoter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonsteraApiServer).AddVoter(ctx, req.(*AddVoterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonsteraApi_UpdateClusterConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateClusterConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonsteraApiServer).UpdateClusterConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonsteraApi_UpdateClusterConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonsteraApiServer).UpdateClusterConfig(ctx, req.(*UpdateClusterConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MonsteraApi_ServiceDesc is the grpc.ServiceDesc for MonsteraApi service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MonsteraApi_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "com.evrblk.monstera.MonsteraApi",
	HandlerType: (*MonsteraApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Update",
			Handler:    _MonsteraApi_Update_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _MonsteraApi_Read_Handler,
		},
		{
			MethodName: "AppendEntries",
			Handler:    _MonsteraApi_AppendEntries_Handler,
		},
		{
			MethodName: "RequestVote",
			Handler:    _MonsteraApi_RequestVote_Handler,
		},
		{
			MethodName: "TimeoutNow",
			Handler:    _MonsteraApi_TimeoutNow_Handler,
		},
		{
			MethodName: "HealthCheck",
			Handler:    _MonsteraApi_HealthCheck_Handler,
		},
		{
			MethodName: "LeadershipTransfer",
			Handler:    _MonsteraApi_LeadershipTransfer_Handler,
		},
		{
			MethodName: "TriggerSnapshot",
			Handler:    _MonsteraApi_TriggerSnapshot_Handler,
		},
		{
			MethodName: "AddVoter",
			Handler:    _MonsteraApi_AddVoter_Handler,
		},
		{
			MethodName: "UpdateClusterConfig",
			Handler:    _MonsteraApi_UpdateClusterConfig_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AppendEntriesPipeline",
			Handler:       _MonsteraApi_AppendEntriesPipeline_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "InstallSnapshot",
			Handler:       _MonsteraApi_InstallSnapshot_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "api.proto",
}
