package codegen

import (
	"fmt"
	"log"

	. "github.com/dave/jennifer/jen"
	"github.com/samber/lo"
)

func GenerateCoreApis(monsteraYaml *MonsteraYaml) string {
	f := NewFilePath(monsteraYaml.GoCode.OutputPackage)
	f.HeaderComment("Code generated by `monstera generate`. DO NOT EDIT.")

	for _, stub := range monsteraYaml.Stubs {
		cores := make([]*MonsteraCore, len(stub.Cores))
		for i, coreName := range stub.Cores {
			core, ok := lo.Find(monsteraYaml.Cores, func(core *MonsteraCore) bool {
				return core.Name == coreName
			})
			if !ok {
				log.Fatalf("core %s not found", coreName)
			}
			cores[i] = core
		}

		generateStubApi(f, stub, cores, monsteraYaml)
	}

	for _, core := range monsteraYaml.Cores {
		generateCoreApi(f, core, monsteraYaml)
	}

	return fmt.Sprintf("%#v", f)
}

func generateCoreApi(f *File, core *MonsteraCore, monsteraYaml *MonsteraYaml) {
	apiName := core.Name + "CoreApi"
	f.Type().Id(apiName).InterfaceFunc(func(g *Group) {
		g.Id("Snapshot").Params().Qual("github.com/evrblk/monstera", "ApplicationCoreSnapshot")
		g.Id("Restore").Params(Id("reader").Qual("io", "ReadCloser")).Error()
		g.Id("Close").Params()

		for _, method := range getAllMethods(core) {
			g.Id(method).Params(
				Id("request").Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, method+"Request"),
			).Params(
				List(
					Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, method+"Response"),
					Error(),
				),
			)
		}
	})
	f.Line()
}

func generateStubApi(f *File, stub *MonsteraStub, cores []*MonsteraCore, monsteraYaml *MonsteraYaml) {
	apiName := stub.Name + "CoreApi"
	f.Type().Id(apiName).InterfaceFunc(func(g *Group) {
		for _, core := range cores {
			for _, read := range core.Reads {
				generateStubApiMethod(g, read.Name, read.Sharded, monsteraYaml)
			}
			for _, update := range core.Updates {
				generateStubApiMethod(g, update.Name, update.Sharded, monsteraYaml)
			}
			g.Line()
		}
	})

	unimplementedApiName := "Unimplemented" + apiName
	f.Var().Id("_").Qual(monsteraYaml.GoCode.OutputPackage, apiName).Op("=").Op("&").Id(unimplementedApiName).Values()

	f.Type().Id(unimplementedApiName).Struct()
	for _, core := range cores {
		for _, read := range core.Reads {
			generateUnimplementedStubApiMethod(f, unimplementedApiName, read.Sharded, read.Name, monsteraYaml)
		}
		for _, update := range core.Updates {
			generateUnimplementedStubApiMethod(f, unimplementedApiName, update.Sharded, update.Name, monsteraYaml)
		}
	}
}

func generateUnimplementedStubApiMethod(f *File, unimplementedApiName string, sharded bool, method string, monsteraYaml *MonsteraYaml) {
	f.Func().Params(
		Id("a").Op("*").Id(unimplementedApiName),
	).Id(method).ParamsFunc(func(g *Group) {
		g.Id("ctx").Qual("context", "Context")
		g.Id("request").Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, method+"Request")
		if !sharded {
			g.Id("shardId").String()
		}
	}).Params(
		List(Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, method+"Response"), Error()),
	).Block(
		Panic(Lit("not implemented")),
	)
	f.Line()
}

func generateStubApiMethod(g *Group, method string, sharded bool, monsteraYaml *MonsteraYaml) {
	if sharded {
		g.Id(method).Params(
			Id("ctx").Qual("context", "Context"),
			Id("request").Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, method+"Request"),
		).Params(
			List(
				Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, method+"Response"),
				Error(),
			),
		)
	} else {
		g.Id(method).Params(
			Id("ctx").Qual("context", "Context"),
			Id("request").Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, method+"Request"),
			Id("shardId").String(),
		).Params(
			List(
				Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, method+"Response"),
				Error(),
			),
		)
	}
}
