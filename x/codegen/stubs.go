package codegen

import (
	"fmt"
	"log"

	. "github.com/dave/jennifer/jen"
)

func GenerateStubs(monsteraYaml *MonsteraYaml) string {
	f := NewFilePath(monsteraYaml.GoCode.OutputPackage)
	f.HeaderComment("Code generated by `monstera generate`. DO NOT EDIT.")
	f.ImportAlias("github.com/evrblk/monstera/x", "monsterax")

	for _, stub := range monsteraYaml.Stubs {
		cores := make([]*MonsteraCore, len(stub.Cores))
		for i, coreName := range stub.Cores {
			found := false
			for _, core := range monsteraYaml.Cores {
				if core.Name == coreName {
					cores[i] = core
					found = true
					break
				}
			}

			if !found {
				log.Fatalf("core %s not found", coreName)
			}
		}

		generateMonsteraShardKeyCalculator(f, stub, cores, monsteraYaml)
		generateMonsteraStub(f, stub, cores, monsteraYaml)
		generateNonclusteredStub(f, stub, cores, monsteraYaml)
	}

	return fmt.Sprintf("%#v", f)
}

func generateMonsteraShardKeyCalculator(f *File, stub *MonsteraStub, cores []*MonsteraCore, monsteraYaml *MonsteraYaml) {
	intfName := stub.Name + "MonsteraShardKeyCalculator"
	f.Type().Id(intfName).InterfaceFunc(func(g *Group) {
		for _, core := range cores {
			for _, read := range core.Reads {
				if read.Sharded {
					g.Id(read.Name + "ShardKey").Params(Id("request").Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, read.Name+"Request")).Index().Byte()
				}
			}
			for _, update := range core.Updates {
				if update.Sharded {
					g.Id(update.Name + "ShardKey").Params(Id("request").Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, update.Name+"Request")).Index().Byte()
				}
			}
			g.Line()
		}
	})
	f.Line()
}

func generateMonsteraStub(f *File, stub *MonsteraStub, cores []*MonsteraCore, monsteraYaml *MonsteraYaml) {
	stubType := stub.Name + "CoreApiMonsteraStub"
	shardCalculatorType := stub.Name + "MonsteraShardKeyCalculator"

	// type <Stub>
	f.Type().Id(stubType).Struct(
		Id("monsteraClient").Op("*").Qual("github.com/evrblk/monstera", "MonsteraClient"),
		Id("shardKeyCalculator").Id(shardCalculatorType),
	)
	apiName := stub.Name + "CoreApi"
	f.Var().Id("_").Qual(monsteraYaml.GoCode.OutputPackage, apiName).Op("=").Op("&").Id(stubType).Values()
	f.Line()

	stubReceiver := Id("s").Op("*").Id(stubType)

	for _, core := range cores {
		for _, read := range core.Reads {
			f.Func().Params(stubReceiver).Id(read.Name).ParamsFunc(func(g *Group) {
				g.Id("ctx").Qual("context", "Context")
				g.Id("request").Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, read.Name+"Request")
				if !read.Sharded {
					g.Id("shardId").String()
				}
			}).Params(
				List(
					Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, read.Name+"Response"),
					Error(),
				),
			).BlockFunc(func(g *Group) {
				g.Id("readRequest").Op(":=").Op("&").Qual(monsteraYaml.GoCode.CorePbPackage, core.ReadRequestProto).Values(
					Id("Request").Op(":").Op("&").Qual(monsteraYaml.GoCode.CorePbPackage, core.ReadRequestProto+"_"+read.Name+"Request").Values(
						Id(read.Name + "Request").Op(":").Id("request"),
					),
				)
				g.List(Id("requestBytes"), Err()).Op(":=").Qual("google.golang.org/protobuf/proto", "Marshal").Call(Id("readRequest"))
				g.If(
					Err().Op("!=").Nil(),
				).Block(
					Return(Id("nil"), Qual("github.com/evrblk/monstera/x", "NewErrorWithContext").Call(
						Qual("github.com/evrblk/monstera/x", "Internal"),
						Lit("failed to marshal request"),
						Map(String()).String().Values(
							Lit("error").Op(":").Err().Dot("Error()"),
						),
					)),
				)
				g.Line()

				if read.Sharded {
					g.Id("shardKey").Op(":=").Id("s.shardKeyCalculator." + read.Name + "ShardKey").Call(
						Id("request"),
					)
					g.Line()

					g.List(Id("responseBytes"), Err()).Op(":=").Id("s.monsteraClient.Read").Call(
						Id("ctx"),
						Lit(core.Name),
						Id("shardKey"),
						Lit(read.AllowReadFromFollowers),
						Id("requestBytes"),
					)
				} else {
					g.Line()

					g.List(Id("responseBytes"), Err()).Op(":=").Id("s.monsteraClient.ReadShard").Call(
						Id("ctx"),
						Lit(core.Name),
						Id("shardId"),
						Lit(read.AllowReadFromFollowers),
						Id("requestBytes"),
					)
				}

				g.If(
					Err().Op("!=").Nil(),
				).Block(
					Return(Id("nil"), Err()),
				)
				g.Line()

				g.Id("readResponse").Op(":=").Op("&").Qual(monsteraYaml.GoCode.CorePbPackage, core.ReadResponseProto).Values()
				g.Err().Op("=").Qual("google.golang.org/protobuf/proto", "Unmarshal").Call(Id("responseBytes"), Id("readResponse"))
				g.If(
					Err().Op("!=").Nil(),
				).Block(
					Return(Id("nil"), Qual("github.com/evrblk/monstera/x", "NewErrorWithContext").Call(
						Qual("github.com/evrblk/monstera/x", "Internal"),
						Lit("failed to unmarshal response"),
						Map(String()).String().Values(
							Lit("error").Op(":").Err().Dot("Error()"),
						),
					)),
				)
				g.Line()

				g.List(Id("response"), Id("ok")).Op(":=").Id("readResponse").Dot("Response").Assert(
					Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, core.ReadResponseProto+"_"+read.Name+"Response"),
				)
				g.If(
					Id("ok"),
				).Block(
					Return(Id("response").Dot(read.Name+"Response"), Id("nilifyIfEmpty").Call(Id("readResponse").Dot("Error"))),
				).Else().Block(
					Return(Id("nil"), Qual("github.com/evrblk/monstera/x", "NewErrorWithContext").Call(
						Qual("github.com/evrblk/monstera/x", "Internal"),
						Lit("invalid response type"),
						Map(String()).String().Values(
							Lit("response").Op(":").Id("readResponse").Dot("String()"),
						),
					)),
				)
			})
			f.Line()
		}

		for _, update := range core.Updates {
			f.Func().Params(stubReceiver).Id(update.Name).ParamsFunc(func(g *Group) {
				g.Id("ctx").Qual("context", "Context")
				g.Id("request").Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, update.Name+"Request")
				if !update.Sharded {
					g.Id("shardId").String()
				}
			}).Params(
				List(
					Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, update.Name+"Response"),
					Error(),
				),
			).BlockFunc(func(g *Group) {
				g.Id("updateRequest").Op(":=").Op("&").Qual(monsteraYaml.GoCode.CorePbPackage, core.UpdateRequestProto).Values(
					Id("Request").Op(":").Op("&").Qual(monsteraYaml.GoCode.CorePbPackage, core.UpdateRequestProto+"_"+update.Name+"Request").Values(
						Id(update.Name + "Request").Op(":").Id("request"),
					),
				)
				g.List(Id("requestBytes"), Err()).Op(":=").Qual("google.golang.org/protobuf/proto", "Marshal").Call(Id("updateRequest"))
				g.If(
					Err().Op("!=").Nil(),
				).Block(
					Return(Id("nil"), Qual("github.com/evrblk/monstera/x", "NewErrorWithContext").Call(
						Qual("github.com/evrblk/monstera/x", "Internal"),
						Lit("failed to marshal request"),
						Map(String()).String().Values(
							Lit("error").Op(":").Err().Dot("Error()"),
						),
					)),
				)
				g.Line()

				if update.Sharded {
					g.Id("shardKey").Op(":=").Id("s.shardKeyCalculator." + update.Name + "ShardKey").Call(
						Id("request"),
					)
					g.Line()

					g.List(Id("responseBytes"), Err()).Op(":=").Id("s.monsteraClient.Update").Call(
						Id("ctx"),
						Lit(core.Name),
						Id("shardKey"),
						Id("requestBytes"),
					)
				} else {
					g.Line()

					g.List(Id("responseBytes"), Err()).Op(":=").Id("s.monsteraClient.UpdateShard").Call(
						Id("ctx"),
						Lit(core.Name),
						Id("shardId"),
						Id("requestBytes"),
					)
				}

				g.If(
					Err().Op("!=").Nil(),
				).Block(
					Return(Id("nil"), Err()),
				)
				g.Line()

				g.Id("updateResponse").Op(":=").Op("&").Qual(monsteraYaml.GoCode.CorePbPackage, core.UpdateResponseProto).Values()
				g.Err().Op("=").Qual("google.golang.org/protobuf/proto", "Unmarshal").Call(Id("responseBytes"), Id("updateResponse"))
				g.If(
					Err().Op("!=").Nil(),
				).Block(
					Return(Id("nil"), Qual("github.com/evrblk/monstera/x", "NewErrorWithContext").Call(
						Qual("github.com/evrblk/monstera/x", "Internal"),
						Lit("failed to unmarshal response"),
						Map(String()).String().Values(
							Lit("error").Op(":").Err().Dot("Error()"),
						),
					)),
				)
				g.Line()

				g.List(Id("response"), Id("ok")).Op(":=").Id("updateResponse").Dot("Response").Assert(
					Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, core.UpdateResponseProto+"_"+update.Name+"Response"),
				)
				g.If(
					Id("ok"),
				).Block(
					Return(Id("response").Dot(update.Name+"Response"), Id("nilifyIfEmpty").Call(Id("updateResponse").Dot("Error"))),
				).Else().Block(
					Return(Id("nil"), Qual("github.com/evrblk/monstera/x", "NewErrorWithContext").Call(
						Qual("github.com/evrblk/monstera/x", "Internal"),
						Lit("invalid response type"),
						Map(String()).String().Values(
							Lit("response").Op(":").Id("updateResponse").Dot("String()"),
						),
					)),
				)
			})
			f.Line()
		}
	}

	// func ListShards()
	f.Func().Params(stubReceiver).Id("ListShards").Params(
		Id("applicationName").String(),
	).Params(
		List(Index().String(), Error()),
	).BlockFunc(func(g *Group) {
		g.List(Id("shards"), Err()).Op(":=").Id("s").Dot("monsteraClient").Dot("ListShards").Call(Id("applicationName"))
		g.If(Err().Op("!=").Nil()).Block(
			Return(Id("nil"), Err()),
		)
		g.Id("shardIds").Op(":=").Make(Index().String(), Len(Id("shards")))
		g.For(Id("i").Op(":=").Range().Id("shards")).Block(
			Id("shardIds").Index(Id("i")).Op("=").Id("shards").Index(Id("i")).Dot("Id"),
		)
		g.Return(Id("shardIds"), Nil())
	})
	f.Line()

	// func New<Stub>
	f.Func().Id("New"+stubType).Params(
		Id("monsteraClient").Op("*").Qual("github.com/evrblk/monstera", "MonsteraClient"),
		Id("shardKeyCalculator").Qual(monsteraYaml.GoCode.OutputPackage, shardCalculatorType),
	).Params(
		Op("*").Id(stubType),
	).Block(
		Return(
			Op("&").Id(stubType).Values(
				Id("monsteraClient").Op(":").Id("monsteraClient"),
				Id("shardKeyCalculator").Op(":").Id("shardKeyCalculator"),
			)),
	)
	f.Line()

	f.Func().Id("nilifyIfEmpty").Params(
		Err().Op("*").Qual("github.com/evrblk/monstera/x", "Error"),
	).Params(
		Error(),
	).Block(
		If(
			Err().Op("==").Nil().Op("||").Id("err.Code").Op("==").Qual("github.com/evrblk/monstera/x", "ErrorCode_INVALID").Op("||").Id("err.Code").Op("==").Qual("github.com/evrblk/monstera/x", "ErrorCode_OK"),
		).Block(
			Return(Nil()),
		).Else().Block(
			Return(Err()),
		),
	)
}

func generateNonclusteredStub(f *File, stub *MonsteraStub, cores []*MonsteraCore, monsteraYaml *MonsteraYaml) {
	adapterTypeName := func(coreName string) string {
		return firstCharToLower(coreName) + "CoreNonclusteredAdapter"
	}

	// core adapters for internal shards
	for _, core := range cores {
		f.Type().Id(adapterTypeName(core.Name)).StructFunc(func(g *Group) {
			g.Id("core").Qual(monsteraYaml.GoCode.OutputPackage, core.Name+"CoreApi")
			g.Id("mu").Qual("sync", "RWMutex")
			g.Id("id").String()
			g.Id("lowerBound").Index().Byte()
			g.Id("upperBound").Index().Byte()
		})
		f.Line()
	}

	// type <Stub>NonclusteredApplicationCoresFactory
	applicationCoresFactoryType := stub.Name + "NonclusteredApplicationCoresFactory"
	f.Type().Id(applicationCoresFactoryType).StructFunc(func(g *Group) {
		for _, core := range cores {
			g.Id(core.Name+"CoreFactoryFunc").Func().Params(Id("shardId").String(), Id("lowerBound").Index().Byte(), Id("upperBound").Index().Byte()).Qual(monsteraYaml.GoCode.OutputPackage, core.Name+"CoreApi")
		}
	})

	stubType := stub.Name + "CoreApiNonclusteredStub"
	shardCalculatorType := stub.Name + "MonsteraShardKeyCalculator"

	// type <Stub>
	f.Type().Id(stubType).StructFunc(func(g *Group) {
		for _, core := range cores {
			g.Id(firstCharToLower(core.Name) + "Cores").Index().Op("*").Id(adapterTypeName(core.Name))
		}
		g.Line()
		g.Id("shardKeyCalculator").Id(shardCalculatorType)
	})
	apiName := stub.Name + "CoreApi"
	f.Var().Id("_").Qual(monsteraYaml.GoCode.OutputPackage, apiName).Op("=").Op("&").Id(stubType).Values()
	f.Line()

	stubReceiver := Id("s").Op("*").Qual(monsteraYaml.GoCode.OutputPackage, stubType)

	for _, core := range cores {
		for _, read := range core.Reads {
			f.Func().Params(stubReceiver).Id(read.Name).ParamsFunc(func(g *Group) {
				g.Id("ctx").Qual("context", "Context")
				g.Id("request").Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, read.Name+"Request")
				if !read.Sharded {
					g.Id("shardId").String()
				}
			}).Params(
				List(
					Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, read.Name+"Response"),
					Error(),
				),
			).BlockFunc(func(g *Group) {
				if read.Sharded {
					g.Id("shardKey").Op(":=").Id("s.shardKeyCalculator." + read.Name + "ShardKey").Call(
						Id("request"),
					)
					g.Line()

					g.For(List(Id("_"), Id("adapter")).Op(":=").Range().Id("s").Dot(firstCharToLower(core.Name) + "Cores")).Block(
						If(Qual("bytes", "Compare").Call(Id("shardKey"), Id("adapter").Dot("upperBound")).Op("<=").Lit(0).Op("&&").
							Qual("bytes", "Compare").Call(Id("shardKey"), Id("adapter").Dot("lowerBound")).Op(">=").Lit(0)).Block(
							Id("adapter").Dot("mu").Dot("RLock").Call(),
							Defer().Id("adapter").Dot("mu").Dot("RUnlock").Call(),
							Line(),
							Return(Id("adapter").Dot("core").Dot(read.Name).Call(
								Id("request"),
							)),
						),
					)
					g.Line()

					g.Return(List(Nil(), Qual("fmt", "Errorf").Call(Lit("no shard found for shardKey: %s"), Id("shardKey"))))
				} else {
					g.For(List(Id("_"), Id("adapter")).Op(":=").Range().Id("s").Dot(firstCharToLower(core.Name) + "Cores")).Block(
						If(Id("adapter").Dot("id").Op("==").Id("shardId")).Block(
							Id("adapter").Dot("mu").Dot("RLock").Call(),
							Defer().Id("adapter").Dot("mu").Dot("RUnlock").Call(),
							Line(),
							Return(Id("adapter").Dot("core").Dot(read.Name).Call(
								Id("request"),
							)),
						),
					)
					g.Line()

					g.Return(List(Nil(), Qual("fmt", "Errorf").Call(Lit("no shard found for shardId: %s"), Id("shardId"))))
				}
			})
			f.Line()
		}

		for _, update := range core.Updates {
			f.Func().Params(stubReceiver).Id(update.Name).ParamsFunc(func(g *Group) {
				g.Id("ctx").Qual("context", "Context")
				g.Id("request").Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, update.Name+"Request")
				if !update.Sharded {
					g.Id("shardId").String()
				}
			}).Params(
				List(
					Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, update.Name+"Response"),
					Error(),
				),
			).BlockFunc(func(g *Group) {
				if update.Sharded {
					g.Id("shardKey").Op(":=").Id("s.shardKeyCalculator." + update.Name + "ShardKey").Call(
						Id("request"),
					)
					g.Line()

					g.For(List(Id("_"), Id("adapter")).Op(":=").Range().Id("s").Dot(firstCharToLower(core.Name) + "Cores")).Block(
						If(Qual("bytes", "Compare").Call(Id("shardKey"), Id("adapter").Dot("upperBound")).Op("<=").Lit(0).Op("&&").
							Qual("bytes", "Compare").Call(Id("shardKey"), Id("adapter").Dot("lowerBound")).Op(">=").Lit(0)).Block(
							Id("adapter").Dot("mu").Dot("Lock").Call(),
							Defer().Id("adapter").Dot("mu").Dot("Unlock").Call(),
							Line(),
							Return(Id("adapter").Dot("core").Dot(update.Name).Call(
								Id("request"),
							)),
						),
					)
					g.Line()

					g.Return(List(Nil(), Qual("fmt", "Errorf").Call(Lit("no shard found for shardKey: %s"), Id("shardKey"))))
				} else {
					g.For(List(Id("_"), Id("adapter")).Op(":=").Range().Id("s").Dot(firstCharToLower(core.Name) + "Cores")).Block(
						If(Id("adapter").Dot("id").Op("==").Id("shardId")).Block(
							Id("adapter").Dot("mu").Dot("Lock").Call(),
							Defer().Id("adapter").Dot("mu").Dot("Unlock").Call(),
							Line(),
							Return(Id("adapter").Dot("core").Dot(update.Name).Call(
								Id("request"),
							)),
						),
					)
					g.Line()

					g.Return(List(Nil(), Qual("fmt", "Errorf").Call(Lit("no shard found for shardId: %s"), Id("shardId"))))
				}

			})
			f.Line()
		}
	}

	// func ListShards()
	f.Func().Params(stubReceiver).Id("ListShards").Params(
		Id("applicationName").String(),
	).Params(
		List(Index().String(), Error()),
	).BlockFunc(func(g *Group) {
		g.Switch(Id("applicationName")).BlockFunc(func(g *Group) {
			for _, core := range cores {
				adapters := firstCharToLower(core.Name) + "Cores"
				g.Case(Lit(core.Name)).Block(
					Id("shardIds").Op(":=").Make(Index().String(), Len(Id("s").Dot(adapters))),
					For(Id("i").Op(":=").Range().Id("s").Dot(adapters)).Block(
						Id("shardIds").Index(Id("i")).Op("=").Id("s").Dot(adapters).Index(Id("i")).Dot("id"),
					),
					Return(List(Id("shardIds"), Nil())),
				)
			}
			g.Default().Block(
				Return(List(Nil(), Qual("fmt", "Errorf").Call(Lit("application not found: %s"), Id("applicationName")))),
			)
		})
	})
	f.Line()

	// func New<Stub>()
	f.Func().Id("New"+stubType).Params(
		Id("shardsPerApp").Int(),
		Id("coresFactory").Op("*").Id(applicationCoresFactoryType),
		Id("shardKeyCalculator").Id(shardCalculatorType),
	).Params(
		Op("*").Id(stubType),
	).BlockFunc(func(g *Group) {
		for _, core := range cores {
			g.Id(firstCharToLower(core.Name)+"Cores").Op(":=").Make(Index().Op("*").Id(adapterTypeName(core.Name)), Id("shardsPerApp"))
		}
		g.Line()

		g.Id("shardSize").Op(":=").Qual("github.com/evrblk/monstera", "KeyspacePerApplication").Op("/").Id("shardsPerApp")

		g.For(Id("i").Op(":=").Lit(0), Id("i").Op("<").Id("shardsPerApp"), Id("i").Op("++")).BlockFunc(func(g *Group) {
			g.Id("lower").Op(":=").Uint32().Call(Id("i").Op("*").Id("shardSize"))
			g.Id("upper").Op(":=").Uint32().Call(Parens(Id("i").Op("+").Lit(1)).Op("*").Id("shardSize").Op("-").Lit(1))
			g.Id("lowerBound").Op(":=").Make(Index().Byte(), Lit(4))
			g.Id("upperBound").Op(":=").Make(Index().Byte(), Lit(4))
			g.Qual("encoding/binary", "BigEndian").Dot("PutUint32").Call(Id("lowerBound"), Id("lower"))
			g.Qual("encoding/binary", "BigEndian").Dot("PutUint32").Call(Id("upperBound"), Id("upper"))
			g.Line()

			g.List(Id("sl"), Id("su")).Op(":=").Qual("github.com/evrblk/monstera", "ShortenBounds").Call(Id("lowerBound"), Id("upperBound"))
			g.Line()

			for _, core := range cores {
				shardIdVarName := firstCharToLower(core.Name) + "ShardId"
				g.Id(shardIdVarName).Op(":=").Qual("fmt", "Sprintf").Call(Lit("%s_%x_%x"), Lit(core.Name), Id("sl"), Id("su"))
				g.Id(firstCharToLower(core.Name)+"Cores").Index(Id("i")).Op("=").Op("&").Id(adapterTypeName(core.Name)).Values(
					Id("core").Op(":").Id("coresFactory").Dot(core.Name+"CoreFactoryFunc").Call(Id(shardIdVarName), Id("lowerBound"), Id("upperBound")),
					Id("id").Op(":").Id(shardIdVarName),
					Id("lowerBound").Op(":").Id("lowerBound"),
					Id("upperBound").Op(":").Id("upperBound"),
				)
				g.Line()
			}
		})

		g.Return(
			Op("&").Id(stubType).ValuesFunc(func(g *Group) {
				for _, core := range cores {
					g.Id(firstCharToLower(core.Name) + "Cores").Op(":").Id(firstCharToLower(core.Name) + "Cores")
				}
				g.Id("shardKeyCalculator").Op(":").Id("shardKeyCalculator")
			}))
	})
}
