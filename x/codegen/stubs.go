package codegen

import (
	"fmt"
	"log"

	"github.com/samber/lo"

	. "github.com/dave/jennifer/jen"
)

func GenerateStubs(monsteraYaml *MonsteraYaml) string {
	f := NewFilePath(monsteraYaml.GoCode.OutputPackage)
	f.HeaderComment("Code generated by `monstera generate`. DO NOT EDIT.")
	f.ImportAlias("github.com/evrblk/monstera/x", "monsterax")

	for _, stub := range monsteraYaml.Stubs {
		cores := make([]*MonsteraCore, len(stub.Cores))
		for i, coreName := range stub.Cores {
			core, ok := lo.Find(monsteraYaml.Cores, func(core *MonsteraCore) bool {
				return core.Name == coreName
			})
			if !ok {
				log.Fatalf("core %s not found", coreName)
			}
			cores[i] = core
		}

		generateMonsteraShardKeyCalculator(f, stub, cores, monsteraYaml)
		generateMonsteraStub(f, stub, cores, monsteraYaml)
		generateStandaloneStub(f, stub, cores, monsteraYaml)
	}

	return fmt.Sprintf("%#v", f)
}

func generateMonsteraShardKeyCalculator(f *File, stub *MonsteraStub, cores []*MonsteraCore, monsteraYaml *MonsteraYaml) {
	intfName := stub.Name + "MonsteraShardKeyCalculator"
	f.Type().Id(intfName).InterfaceFunc(func(g *Group) {
		for _, core := range cores {
			for _, read := range core.Reads {
				if read.Sharded {
					g.Id(read.Name + "ShardKey").Params(Id("request").Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, read.Name+"Request")).Index().Byte()
				}
			}
			for _, update := range core.Updates {
				if update.Sharded {
					g.Id(update.Name + "ShardKey").Params(Id("request").Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, update.Name+"Request")).Index().Byte()
				}
			}
			g.Line()
		}
	})
	f.Line()
}

func generateMonsteraStub(f *File, stub *MonsteraStub, cores []*MonsteraCore, monsteraYaml *MonsteraYaml) {
	stubName := stub.Name + "CoreApiMonsteraStub"
	f.Type().Id(stubName).Struct(
		Id("monsteraClient").Op("*").Qual("github.com/evrblk/monstera", "MonsteraClient"),
		Id("shardKeyCalculator").Id(stub.Name+"MonsteraShardKeyCalculator"),
	)
	apiName := stub.Name + "CoreApi"
	f.Var().Id("_").Qual(monsteraYaml.GoCode.OutputPackage, apiName).Op("=").Op("&").Id(stubName).Values()
	f.Line()

	for _, core := range cores {
		for _, read := range core.Reads {
			f.Func().Params(
				Id("s").Op("*").Id(stubName),
			).Id(read.Name).ParamsFunc(func(g *Group) {
				g.Id("ctx").Qual("context", "Context")
				g.Id("request").Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, read.Name+"Request")
				if !read.Sharded {
					g.Id("shardId").String()
				}
			}).Params(
				List(
					Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, read.Name+"Response"),
					Error(),
				),
			).BlockFunc(func(g *Group) {
				g.Id("readRequest").Op(":=").Op("&").Qual(monsteraYaml.GoCode.CorePbPackage, core.ReadRequestProto).Values(
					Id("Request").Op(":").Op("&").Qual(monsteraYaml.GoCode.CorePbPackage, core.ReadRequestProto+"_"+read.Name+"Request").Values(
						Id(read.Name + "Request").Op(":").Id("request"),
					),
				)
				g.Id("readResponse").Op(":=").Op("&").Qual(monsteraYaml.GoCode.CorePbPackage, core.ReadResponseProto).Values()

				if read.Sharded {
					g.Id("shardKey").Op(":=").Id("s.shardKeyCalculator." + read.Name + "ShardKey").Call(
						Id("request"),
					)
					g.Line()

					g.Id("err").Op(":=").Id("s.monsteraClient.Read").Call(
						Id("ctx"),
						Lit(core.Name),
						Id("shardKey"),
						Lit(read.AllowReadFromFollowers),
						Id("readRequest"),
						Id("readResponse"),
					)
				} else {
					g.Line()

					g.Id("err").Op(":=").Id("s.monsteraClient.ReadShard").Call(
						Id("ctx"),
						Lit(core.Name),
						Id("shardId"),
						Lit(read.AllowReadFromFollowers),
						Id("readRequest"),
						Id("readResponse"),
					)
				}

				g.If(
					Id("err").Op("!=").Nil(),
				).Block(
					Return(Id("nil"), Id("err")),
				)
				g.Line()

				g.List(Id("response"), Id("ok")).Op(":=").Id("readResponse").Dot("Response").Assert(
					Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, core.ReadResponseProto+"_"+read.Name+"Response"),
				)
				g.If(
					Id("ok"),
				).Block(
					Return(Id("response").Dot(read.Name+"Response"), Id("nilifyIfEmpty").Call(Id("readResponse").Dot("Error"))),
				).Else().Block(
					Return(Id("nil"), Qual("github.com/evrblk/monstera/x", "NewErrorWithContext").Call(
						Qual("github.com/evrblk/monstera/x", "Internal"),
						Lit("invalid response type"),
						Map(String()).String().Values(
							Lit("response").Op(":").Id("readResponse").Dot("String()"),
						),
					)),
				)
			})
			f.Line()
		}

		for _, update := range core.Updates {
			f.Func().Params(
				Id("s").Op("*").Id(stubName),
			).Id(update.Name).ParamsFunc(func(g *Group) {
				g.Id("ctx").Qual("context", "Context")
				g.Id("request").Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, update.Name+"Request")
				if !update.Sharded {
					g.Id("shardId").String()
				}
			}).Params(
				List(
					Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, update.Name+"Response"),
					Error(),
				),
			).BlockFunc(func(g *Group) {
				g.Id("updateRequest").Op(":=").Op("&").Qual(monsteraYaml.GoCode.CorePbPackage, core.UpdateRequestProto).Values(
					Id("Request").Op(":").Op("&").Qual(monsteraYaml.GoCode.CorePbPackage, core.UpdateRequestProto+"_"+update.Name+"Request").Values(
						Id(update.Name + "Request").Op(":").Id("request"),
					),
				)
				g.Id("updateResponse").Op(":=").Op("&").Qual(monsteraYaml.GoCode.CorePbPackage, core.UpdateResponseProto).Values()

				if update.Sharded {
					g.Id("shardKey").Op(":=").Id("s.shardKeyCalculator." + update.Name + "ShardKey").Call(
						Id("request"),
					)
					g.Line()

					g.Id("err").Op(":=").Id("s.monsteraClient.Update").Call(
						Id("ctx"),
						Lit(core.Name),
						Id("shardKey"),
						Id("updateRequest"),
						Id("updateResponse"),
					)
				} else {
					g.Line()

					g.Id("err").Op(":=").Id("s.monsteraClient.UpdateShard").Call(
						Id("ctx"),
						Lit(core.Name),
						Id("shardId"),
						Id("updateRequest"),
						Id("updateResponse"),
					)
				}

				g.If(
					Id("err").Op("!=").Nil(),
				).Block(
					Return(Id("nil"), Id("err")),
				)
				g.Line()

				g.List(Id("response"), Id("ok")).Op(":=").Id("updateResponse").Dot("Response").Assert(
					Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, core.UpdateResponseProto+"_"+update.Name+"Response"),
				)
				g.If(
					Id("ok"),
				).Block(
					Return(Id("response").Dot(update.Name+"Response"), Id("nilifyIfEmpty").Call(Id("updateResponse").Dot("Error"))),
				).Else().Block(
					Return(Id("nil"), Qual("github.com/evrblk/monstera/x", "NewErrorWithContext").Call(
						Qual("github.com/evrblk/monstera/x", "Internal"),
						Lit("invalid response type"),
						Map(String()).String().Values(
							Lit("response").Op(":").Id("updateResponse").Dot("String()"),
						),
					)),
				)
			})
			f.Line()
		}
	}

	f.Func().Id("New"+stubName).Params(
		Id("monsteraClient").Op("*").Qual("github.com/evrblk/monstera", "MonsteraClient"),
		Id("shardKeyCalculator").Qual(monsteraYaml.GoCode.OutputPackage, stub.Name+"MonsteraShardKeyCalculator"),
	).Params(
		Op("*").Id(stubName),
	).Block(
		Return(
			Op("&").Id(stubName).Values(
				Id("monsteraClient").Op(":").Id("monsteraClient"),
				Id("shardKeyCalculator").Op(":").Id("shardKeyCalculator"),
			)),
	)
	f.Line()

	f.Func().Id("nilifyIfEmpty").Params(
		Id("err").Op("*").Qual("github.com/evrblk/monstera/x", "Error"),
	).Params(
		Error(),
	).Block(
		If(
			Id("err").Op("==").Nil().Op("||").Id("err.Code").Op("==").Qual("github.com/evrblk/monstera/x", "ErrorCode_INVALID").Op("||").Id("err.Code").Op("==").Qual("github.com/evrblk/monstera/x", "ErrorCode_OK"),
		).Block(
			Return(Nil()),
		).Else().Block(
			Return(Id("err")),
		),
	)
}

func generateStandaloneStub(f *File, stub *MonsteraStub, cores []*MonsteraCore, monsteraYaml *MonsteraYaml) {
	stubName := stub.Name + "CoreApiStandaloneStub"

	f.Type().Id(stubName).StructFunc(func(g *Group) {
		for _, core := range cores {
			g.Id(firstCharToLower(core.Name)+"Core").Qual(monsteraYaml.GoCode.OutputPackage, core.Name+"CoreApi")
		}
		g.Line()

		g.Id("mu").Qual("sync", "RWMutex")
	})
	apiName := stub.Name + "CoreApi"
	f.Var().Id("_").Qual(monsteraYaml.GoCode.OutputPackage, apiName).Op("=").Op("&").Id(stubName).Values()
	f.Line()

	for _, core := range cores {
		for _, read := range core.Reads {
			f.Func().Params(
				Id("s").Op("*").Qual(monsteraYaml.GoCode.OutputPackage, stubName),
			).Id(read.Name).ParamsFunc(func(g *Group) {
				g.Id("ctx").Qual("context", "Context")
				g.Id("request").Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, read.Name+"Request")
				if !read.Sharded {
					g.Id("shardId").String()
				}
			}).Params(
				List(
					Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, read.Name+"Response"),
					Error(),
				),
			).Block(
				Id("s.mu.RLock").Call(),
				Defer().Id("s.mu.RUnlock").Call(),
				Line(),
				Return(Id("s").Dot(firstCharToLower(core.Name)+"Core").Dot(read.Name).Call(
					Id("request"),
				)),
			)
			f.Line()
		}

		for _, update := range core.Updates {
			f.Func().Params(
				Id("s").Op("*").Qual(monsteraYaml.GoCode.OutputPackage, stubName),
			).Id(update.Name).ParamsFunc(func(g *Group) {
				g.Id("ctx").Qual("context", "Context")
				g.Id("request").Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, update.Name+"Request")
				if !update.Sharded {
					g.Id("shardId").String()
				}
			}).Params(
				List(
					Op("*").Qual(monsteraYaml.GoCode.CorePbPackage, update.Name+"Response"),
					Error(),
				),
			).Block(
				Id("s.mu.Lock").Call(),
				Defer().Id("s.mu.Unlock").Call(),
				Line(),
				Return(Id("s").Dot(firstCharToLower(core.Name)+"Core").Dot(update.Name).Call(
					Id("request"),
				)),
			)
			f.Line()
		}
	}

	f.Func().Id("New" + stubName).ParamsFunc(func(g *Group) {
		for _, core := range cores {
			g.Id(firstCharToLower(core.Name)+"Core").Qual(monsteraYaml.GoCode.OutputPackage, core.Name+"CoreApi")
		}
	}).Params(
		Op("*").Id(stubName),
	).Block(
		Return(
			Op("&").Id(stubName).ValuesFunc(func(g *Group) {
				for _, core := range cores {
					g.Id(firstCharToLower(core.Name) + "Core").Op(":").Id(firstCharToLower(core.Name) + "Core")
				}
			})),
	)
}
